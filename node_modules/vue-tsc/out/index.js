"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProgram = void 0;
const ts = require("typescript");
const vue = require("@vue/language-core");
const vueTs = require("@vue/typescript");
const shared_1 = require("./shared");
const vscode_uri_1 = require("vscode-uri");
const fs = require("fs");
function createProgram(options) {
    if (!options.options.noEmit && !options.options.emitDeclarationOnly)
        throw toThrow('js emit is not supported');
    if (!options.options.noEmit && options.options.noEmitOnError)
        throw toThrow('noEmitOnError is not supported');
    if (options.options.extendedDiagnostics || options.options.generateTrace)
        throw toThrow('--extendedDiagnostics / --generateTrace is not supported, please run `Write Virtual Files` in VSCode to write virtual files and use `--extendedDiagnostics` / `--generateTrace` via tsc instead of vue-tsc to debug.');
    if (!options.host)
        throw toThrow('!options.host');
    let program = options.oldProgram;
    if (shared_1.state.hook) {
        program = shared_1.state.hook.program;
        program.__vue.options = options;
    }
    else if (!program) {
        const ctx = {
            projectVersion: 0,
            options,
            get languageHost() {
                return languageHost;
            },
            get vueCompilerOptions() {
                return vueCompilerOptions;
            },
            get languageService() {
                return vueTsLs;
            },
        };
        const vueCompilerOptions = getVueCompilerOptions();
        const scripts = new Map();
        const languageHost = {
            getCompilationSettings: () => ctx.options.options,
            getScriptFileNames: () => {
                return ctx.options.rootNames;
            },
            getScriptSnapshot,
            getProjectVersion: () => {
                return ctx.projectVersion;
            },
            getProjectReferences: () => ctx.options.projectReferences,
            getCurrentDirectory: () => ctx.options.host.getCurrentDirectory().replace(/\\/g, '/'),
            getCancellationToken: ctx.options.host.getCancellationToken ? () => ctx.options.host.getCancellationToken() : undefined,
        };
        const uriToFileName = (uri) => vscode_uri_1.URI.parse(uri).fsPath.replace(/\\/g, '/');
        const fileNameToUri = (fileName) => vscode_uri_1.URI.file(fileName).toString();
        const vueTsLs = vueTs.createLanguageService(languageHost, vueCompilerOptions, ts, {
            uriToFileName,
            fileNameToUri,
            rootUri: vscode_uri_1.URI.parse(fileNameToUri(languageHost.getCurrentDirectory())),
            fs: {
                stat(uri) {
                    if (uri.startsWith('file://')) {
                        try {
                            const stats = fs.statSync(uriToFileName(uri), { throwIfNoEntry: false });
                            if (stats) {
                                return {
                                    type: stats.isFile() ? 1
                                        : stats.isDirectory() ? 2
                                            : stats.isSymbolicLink() ? 64
                                                : 0,
                                    ctime: stats.ctimeMs,
                                    mtime: stats.mtimeMs,
                                    size: stats.size,
                                };
                            }
                        }
                        catch {
                            return undefined;
                        }
                    }
                },
                readFile(uri, encoding) {
                    if (uri.startsWith('file://')) {
                        try {
                            return fs.readFileSync(uriToFileName(uri), { encoding: encoding ?? 'utf-8' });
                        }
                        catch {
                            return undefined;
                        }
                    }
                },
                readDirectory(uri) {
                    if (uri.startsWith('file://')) {
                        try {
                            const dirName = uriToFileName(uri);
                            const files = fs.readdirSync(dirName, { withFileTypes: true });
                            return files.map(file => {
                                return [file.name, file.isFile() ? 1
                                        : file.isDirectory() ? 2
                                            : file.isSymbolicLink() ? 64
                                                : 0];
                            });
                        }
                        catch {
                            return [];
                        }
                    }
                    return [];
                },
            },
        });
        program = vueTsLs.getProgram();
        program.__vue = ctx;
        function getVueCompilerOptions() {
            const tsConfig = ctx.options.options.configFilePath;
            if (typeof tsConfig === 'string') {
                return vue.createParsedCommandLine(ts, ts.sys, tsConfig).vueOptions;
            }
            return {};
        }
        function getScriptSnapshot(fileName) {
            return getScript(fileName)?.scriptSnapshot;
        }
        function getScript(fileName) {
            const script = scripts.get(fileName);
            if (script?.projectVersion === ctx.projectVersion) {
                return script;
            }
            const modifiedTime = ts.sys.getModifiedTime?.(fileName)?.valueOf() ?? 0;
            if (script?.modifiedTime === modifiedTime) {
                return script;
            }
            if (ctx.options.host.fileExists(fileName)) {
                const fileContent = ctx.options.host.readFile(fileName);
                if (fileContent !== undefined) {
                    const script = {
                        projectVersion: ctx.projectVersion,
                        modifiedTime,
                        scriptSnapshot: ts.ScriptSnapshot.fromString(fileContent),
                        version: ctx.options.host.createHash?.(fileContent) ?? fileContent,
                    };
                    scripts.set(fileName, script);
                    return script;
                }
            }
        }
    }
    else {
        const ctx = program.__vue;
        ctx.options = options;
        ctx.projectVersion++;
    }
    const vueCompilerOptions = program.__vue.vueCompilerOptions;
    if (vueCompilerOptions?.hooks) {
        const index = (shared_1.state.hook?.index ?? -1) + 1;
        if (index < vueCompilerOptions.hooks.length) {
            const hookPath = vueCompilerOptions.hooks[index];
            const hook = require(hookPath);
            shared_1.state.hook = {
                program,
                index,
                worker: (async () => await hook(program))(),
            };
            throw 'hook';
        }
    }
    for (const rootName of options.rootNames) {
        // register file watchers
        options.host.getSourceFile(rootName, ts.ScriptTarget.ESNext);
    }
    return program;
}
exports.createProgram = createProgram;
function toThrow(msg) {
    console.error(msg);
    return msg;
}
//# sourceMappingURL=index.js.map